From 2c14feca6ad6d2c3af3ad378014f1e766188676d Mon Sep 17 00:00:00 2001
From: Chenyi Qiang <chenyi.qiang@intel.com>
Date: Fri, 30 Jul 2021 17:06:28 +0800
Subject: [PATCH 088/101] i386/tdx: Trim the XFAM-controlled features according
 to XFAM setting

XFAM (eXtended Features Available Mask) is defiend as a 64b bitmap,
which uses the state-component bitmap format, the same as XCR0 or
IA32_XSS MSR. XFAM determines the set of extended features available for
use by the guest TD.

In TDX 1.0, the enumeration of XSAVE related features are controlled by
their corresponding XFAM bits. I.e., all AVX512 features are controlled
by XFAM[7:5] that if XFAM[7:5] is 000b, the avx512f, avx512dq,
avx512fma, ..., etc are 0.

Since XFAM setting is passed to KVM by CPUID leaf 0xD (specifically,
leaves FEAT_XSAVE_XCR0_LO, FEAT_XSAVE_XCR0_HI, FEAT_XSAVE_XSS_LO,
FEAT_XSAVE_XSS_HI) apply XFAM dependencies after xsave components are
finalized.

Signed-off-by: Chenyi Qiang <chenyi.qiang@intel.com>
Signed-off-by: Xiaoyao Li <xiaoyao.li@intel.com>
---
 target/i386/cpu.c          |   7 +++
 target/i386/cpu.h          |  22 ++++++++
 target/i386/kvm/tdx-stub.c |   4 ++
 target/i386/kvm/tdx.c      | 101 +++++++++++++++++++++++++++++++++++++
 target/i386/kvm/tdx.h      |   1 +
 5 files changed, 135 insertions(+)

diff --git a/target/i386/cpu.c b/target/i386/cpu.c
index a8d1ec8b07..8c74bbaf23 100644
--- a/target/i386/cpu.c
+++ b/target/i386/cpu.c
@@ -40,6 +40,7 @@
 #include "exec/address-spaces.h"
 #include "hw/boards.h"
 #include "hw/i386/sgx-epc.h"
+#include "kvm/tdx.h"
 #endif
 
 #include "disas/capstone.h"
@@ -6362,6 +6363,12 @@ void x86_cpu_expand_features(X86CPU *cpu, Error **errp)
     x86_cpu_enable_xsave_components(cpu);
 
     /* CPUID[EAX=7,ECX=0].EBX always increased level automatically: */
+#ifndef CONFIG_USER_ONLY
+    if (is_tdx_vm()) {
+        tdx_apply_xfam_dependencies(CPU(cpu));
+    }
+#endif
+
     x86_cpu_adjust_feat_level(cpu, FEAT_7_0_EBX);
     if (cpu->full_cpuid_auto_level) {
         x86_cpu_adjust_feat_level(cpu, FEAT_1_EDX);
diff --git a/target/i386/cpu.h b/target/i386/cpu.h
index 708707678c..80d38f7a37 100644
--- a/target/i386/cpu.h
+++ b/target/i386/cpu.h
@@ -553,7 +553,11 @@ typedef enum X86Seg {
 #define XSTATE_OPMASK_BIT               5
 #define XSTATE_ZMM_Hi256_BIT            6
 #define XSTATE_Hi16_ZMM_BIT             7
+#define XSTATE_RTIT_BIT                 8
 #define XSTATE_PKRU_BIT                 9
+#define XSTATE_CET_U_BIT                11
+#define XSTATE_CET_S_BIT                12
+#define XSTATE_UINTR_BIT                14
 #define XSTATE_ARCH_LBR_BIT             15
 #define XSTATE_XTILE_CFG_BIT            17
 #define XSTATE_XTILE_DATA_BIT           18
@@ -566,13 +570,25 @@ typedef enum X86Seg {
 #define XSTATE_OPMASK_MASK              (1ULL << XSTATE_OPMASK_BIT)
 #define XSTATE_ZMM_Hi256_MASK           (1ULL << XSTATE_ZMM_Hi256_BIT)
 #define XSTATE_Hi16_ZMM_MASK            (1ULL << XSTATE_Hi16_ZMM_BIT)
+#define XSTATE_RTIT_MASK                (1ULL << XSTATE_RTIT_BIT)
 #define XSTATE_PKRU_MASK                (1ULL << XSTATE_PKRU_BIT)
+#define XSTATE_CET_U_MASK               (1ULL << XSTATE_CET_U_BIT)
+#define XSTATE_CET_S_MASK               (1ULL << XSTATE_CET_S_BIT)
+#define XSTATE_UINTR_MASK               (1ULL << XSTATE_UINTR_BIT)
 #define XSTATE_ARCH_LBR_MASK            (1ULL << XSTATE_ARCH_LBR_BIT)
 #define XSTATE_XTILE_CFG_MASK           (1ULL << XSTATE_XTILE_CFG_BIT)
 #define XSTATE_XTILE_DATA_MASK          (1ULL << XSTATE_XTILE_DATA_BIT)
 
 #define XSTATE_DYNAMIC_MASK             (XSTATE_XTILE_DATA_MASK)
 
+#define XSTATE_AVX_512_MASK             (XSTATE_OPMASK_MASK |       \
+                                         XSTATE_ZMM_Hi256_MASK |    \
+                                         XSTATE_Hi16_ZMM_MASK)
+#define XSTATE_CET_MASK                 (XSTATE_CET_U_MASK  |       \
+                                         XSTATE_CET_S_MASK)
+#define XSTATE_AMX_MASK                 (XSTATE_XTILE_CFG_MASK |    \
+                                         XSTATE_XTILE_DATA_MASK)
+
 #define ESA_FEATURE_ALIGN64_BIT         1
 #define ESA_FEATURE_XFD_BIT             2
 
@@ -850,6 +866,8 @@ uint64_t x86_cpu_get_supported_feature_word(FeatureWord w,
 #define CPUID_7_0_ECX_WAITPKG           (1U << 5)
 /* Additional AVX-512 Vector Byte Manipulation Instruction */
 #define CPUID_7_0_ECX_AVX512_VBMI2      (1U << 6)
+/* CET SHSTK feature */
+#define CPUID_7_0_ECX_CET_SHSTK         (1U << 7)
 /* Galois Field New Instructions */
 #define CPUID_7_0_ECX_GFNI              (1U << 8)
 /* Vector AES Instructions */
@@ -895,6 +913,8 @@ uint64_t x86_cpu_get_supported_feature_word(FeatureWord w,
 #define CPUID_7_0_EDX_AVX512_4FMAPS     (1U << 3)
 /* Fast Short Rep Mov */
 #define CPUID_7_0_EDX_FSRM              (1U << 4)
+/* User Interrupt Support*/
+#define CPUID_7_0_EDX_UNIT              (1U << 5)
 /* AVX512 Vector Pair Intersection to a Pair of Mask Registers */
 #define CPUID_7_0_EDX_AVX512_VP2INTERSECT (1U << 8)
 /* SERIALIZE instruction */
@@ -905,6 +925,8 @@ uint64_t x86_cpu_get_supported_feature_word(FeatureWord w,
 #define CPUID_7_0_EDX_PCONFIG           (1U << 18)
 /* Architectural LBRs */
 #define CPUID_7_0_EDX_ARCH_LBR          (1U << 19)
+/* CET IBT feature */
+#define CPUID_7_0_EDX_CET_IBT           (1U << 20)
 /* AMX_BF16 instruction */
 #define CPUID_7_0_EDX_AMX_BF16          (1U << 22)
 /* AVX512_FP16 instruction */
diff --git a/target/i386/kvm/tdx-stub.c b/target/i386/kvm/tdx-stub.c
index e26e2111f6..84282927b9 100644
--- a/target/i386/kvm/tdx-stub.c
+++ b/target/i386/kvm/tdx-stub.c
@@ -20,3 +20,7 @@ int tdx_parse_tdvf(void *flash_ptr, int size)
 void tdx_handle_exit(X86CPU *cpu, struct kvm_tdx_exit *tdx_exit)
 {
 }
+
+void tdx_apply_xfam_dependencies(CPUState *cpu)
+{
+}
diff --git a/target/i386/kvm/tdx.c b/target/i386/kvm/tdx.c
index 50d171dd91..401e5453f7 100644
--- a/target/i386/kvm/tdx.c
+++ b/target/i386/kvm/tdx.c
@@ -56,6 +56,87 @@ static FeatureMask tdx_attrs_ctrl_fields[TDX_ATTRIBUTES_MAX_BITS] = {
     [31] = { .index = FEAT_7_0_ECX, .mask = CPUID_7_0_ECX_KeyLocker},
 };
 
+static FeatureDep xfam_dependencies[] = {
+    /* XFAM[7:5] may be set to 111 only when XFAM[2] is set to 1 */
+    {
+        .from = { FEAT_XSAVE_XCR0_LO, XSTATE_YMM_MASK },
+        .to = { FEAT_XSAVE_XCR0_LO, XSTATE_AVX_512_MASK },
+    },
+    {
+        .from = { FEAT_XSAVE_XCR0_LO, XSTATE_YMM_MASK },
+        .to = { FEAT_1_ECX,
+                CPUID_EXT_FMA | CPUID_EXT_AVX | CPUID_EXT_F16C },
+    },
+    {
+        .from = { FEAT_XSAVE_XCR0_LO, XSTATE_YMM_MASK },
+        .to = { FEAT_7_0_EBX, CPUID_7_0_EBX_AVX2 },
+    },
+    {
+        .from = { FEAT_XSAVE_XCR0_LO, XSTATE_YMM_MASK },
+        .to = { FEAT_7_0_ECX, CPUID_7_0_ECX_VAES | CPUID_7_0_ECX_VPCLMULQDQ},
+    },
+    {
+        .from = { FEAT_XSAVE_XCR0_LO, XSTATE_AVX_512_MASK },
+        .to = { FEAT_7_0_EBX,
+                CPUID_7_0_EBX_AVX512F | CPUID_7_0_EBX_AVX512DQ |
+                CPUID_7_0_EBX_AVX512IFMA | CPUID_7_0_EBX_AVX512PF |
+                CPUID_7_0_EBX_AVX512ER | CPUID_7_0_EBX_AVX512CD |
+                CPUID_7_0_EBX_AVX512BW | CPUID_7_0_EBX_AVX512VL },
+    },
+    {
+        .from = { FEAT_XSAVE_XCR0_LO, XSTATE_AVX_512_MASK },
+        .to = { FEAT_7_0_ECX,
+                CPUID_7_0_ECX_AVX512_VBMI | CPUID_7_0_ECX_AVX512_VBMI2 |
+                CPUID_7_0_ECX_AVX512VNNI | CPUID_7_0_ECX_AVX512BITALG |
+                CPUID_7_0_ECX_AVX512_VPOPCNTDQ },
+    },
+    {
+        .from = { FEAT_XSAVE_XCR0_LO, XSTATE_AVX_512_MASK },
+        .to = { FEAT_7_0_EDX,
+                CPUID_7_0_EDX_AVX512_4VNNIW | CPUID_7_0_EDX_AVX512_4FMAPS |
+                CPUID_7_0_EDX_AVX512_VP2INTERSECT | CPUID_7_0_EDX_AVX512_FP16 },
+    },
+    {
+        .from = { FEAT_XSAVE_XCR0_LO, XSTATE_AVX_512_MASK },
+        .to = { FEAT_7_1_EAX, CPUID_7_1_EAX_AVX512_BF16 | CPUID_7_1_EAX_AVX_VNNI },
+    },
+    {
+        .from = { FEAT_XSAVE_XCR0_LO, XSTATE_PKRU_MASK },
+        .to = { FEAT_7_0_ECX, CPUID_7_0_ECX_PKU },
+    },
+    {
+        .from = { FEAT_XSAVE_XCR0_LO, XSTATE_AMX_MASK },
+        .to = { FEAT_7_0_EDX,
+                CPUID_7_0_EDX_AMX_BF16 | CPUID_7_0_EDX_AMX_TILE |
+                CPUID_7_0_EDX_AMX_INT8}
+    },
+    /* XSS features */
+    {
+        .from = { FEAT_XSAVE_XSS_LO, XSTATE_RTIT_MASK },
+        .to = { FEAT_7_0_EBX, CPUID_7_0_EBX_INTEL_PT },
+    },
+    {
+        .from = { FEAT_XSAVE_XSS_LO, XSTATE_RTIT_MASK },
+        .to = { FEAT_14_0_ECX, ~0ull },
+    },
+    {
+        .from = { FEAT_XSAVE_XSS_LO, XSTATE_CET_MASK },
+        .to = { FEAT_7_0_ECX, CPUID_7_0_ECX_CET_SHSTK },
+    },
+    {
+        .from = { FEAT_XSAVE_XSS_LO, XSTATE_CET_MASK },
+        .to = { FEAT_7_0_EDX, CPUID_7_0_EDX_CET_IBT },
+    },
+    {
+        .from = { FEAT_XSAVE_XSS_LO, XSTATE_UINTR_MASK },
+        .to = { FEAT_7_0_EDX, CPUID_7_0_EDX_UNIT },
+    },
+    {
+        .from = { FEAT_XSAVE_XSS_LO, XSTATE_ARCH_LBR_MASK },
+        .to = { FEAT_7_0_EDX, CPUID_7_0_EDX_ARCH_LBR },
+    },
+};
+
 typedef struct KvmTdxCpuidLookup {
     uint32_t tdx_fixed0;
     uint32_t tdx_fixed1;
@@ -309,6 +390,26 @@ void tdx_get_supported_cpuid(uint32_t function, uint32_t index, int reg,
         *ret &= ~CPUID_EXT_MONITOR;
 }
 
+void tdx_apply_xfam_dependencies(CPUState *cpu)
+{
+    X86CPU *x86_cpu = X86_CPU(cpu);
+    CPUX86State *env = &x86_cpu->env;
+    int i;
+
+    for (i = 0; i < ARRAY_SIZE(xfam_dependencies); i++) {
+        FeatureDep *d = &xfam_dependencies[i];
+        if (!(env->features[d->from.index] & d->from.mask)) {
+            uint64_t unavailable_features = env->features[d->to.index] & d->to.mask;
+
+            /* Not an error unless the dependent feature was added explicitly */
+            mark_unavailable_features(x86_cpu, d->to.index,
+                                     unavailable_features & env->user_plus_features[d->to.index],
+                                     "This feature cannot be enabled because its XFAM controlling bit is not enabled");
+            env->features[d->to.index] &= ~unavailable_features;
+        }
+    }
+}
+
 enum tdx_ioctl_level{
     TDX_PLATFORM_IOCTL,
     TDX_VM_IOCTL,
diff --git a/target/i386/kvm/tdx.h b/target/i386/kvm/tdx.h
index d861d85166..447b5555df 100644
--- a/target/i386/kvm/tdx.h
+++ b/target/i386/kvm/tdx.h
@@ -69,5 +69,6 @@ int tdx_pre_create_vcpu(CPUState *cpu);
 void tdx_set_tdvf_region(MemoryRegion *tdvf_region);
 int tdx_parse_tdvf(void *flash_ptr, int size);
 void tdx_handle_exit(X86CPU *cpu, struct kvm_tdx_exit *tdx_exit);
+void tdx_apply_xfam_dependencies(CPUState *cpu);
 
 #endif /* QEMU_I386_TDX_H */
-- 
2.39.2

